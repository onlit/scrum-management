# TraceId Implementation Conventions & Best Practices

This document outlines the standard conventions for implementing traceId across the compute-rapi application to ensure consistent request tracking and observability.

## Overview

TraceId is a unique identifier (UUID v4) generated for each HTTP request that enables correlation of logs, errors, and operations across the entire request lifecycle. This system provides comprehensive observability and debugging capabilities.

## Core Principles

1. **Every request gets a traceId** - Automatically generated by middleware
2. **TraceId flows through all operations** - Controllers, database operations, error handling
3. **Standardized logging patterns** - Use provided utilities, don't manually extract traceId
4. **Error correlation** - All errors include traceId for debugging
5. **Performance tracking** - Log operation start/success for monitoring

## Implementation Guidelines

### 1. Controller Functions

**✅ CORRECT Implementation:**

```javascript
const {
  logOperationStart,
  logOperationSuccess,
  logOperationError,
  logDatabaseStart,
  logDatabaseSuccess,
  createErrorWithTrace,
} = require('#utils/shared/traceUtils.js');

const createResource = async (req, res) => {
  const { user, body } = req;

  // Log operation start with context
  logOperationStart('createResource', req, { 
    user: user.id, 
    bodyKeys: Object.keys(body) 
  });

  try {
    // Validation logging
    const values = await resourceSchema.validateAsync(body);

    // Database operation logging
    logDatabaseStart('create_resource', req, { name: values.name });
    const resource = await prisma.resource.create({
      data: buildCreateRecordPayload({ validatedValues: values, requestBody: body, user }),
    });
    logDatabaseSuccess('create_resource', req, { id: resource.id });

    // Success logging
    logOperationSuccess('createResource', req, { id: resource.id });
    res.status(201).json(resource);
  } catch (error) {
    // Error logging (automatic traceId inclusion)
    logOperationError('createResource', req, error);
    
    if (error.isJoi) {
      throw handleValidationError(error, 'resource_creation');
    }
    throw handleDatabaseError(error, 'resource_creation');
  }
};
```

**❌ INCORRECT Implementation:**

```javascript
// DON'T DO THIS - Manual traceId extraction
const createResource = async (req, res) => {
  const traceId = req.traceId || 'unknown-trace-id'; // ❌ Manual extraction
  console.log(`[${traceId}] Creating resource`); // ❌ Manual logging
  
  try {
    const resource = await prisma.resource.create(data);
    console.log(`[${traceId}] Resource created: ${resource.id}`); // ❌ Manual logging
    res.status(201).json(resource);
  } catch (error) {
    console.error(`[${traceId}] Error: ${error.message}`); // ❌ Manual logging
    throw error; // ❌ No error enhancement
  }
};
```

### 2. Error Handling

**✅ CORRECT Error Creation:**

```javascript
// Use createErrorWithTrace for automatic traceId inclusion
if (!requiredField) {
  const error = createErrorWithTrace(
    ERROR_TYPES.VALIDATION,
    'Required field is missing',
    req,
    {
      severity: ERROR_SEVERITY.MEDIUM,
      context: 'field_validation',
      details: { field: 'requiredField' },
    }
  );
  logOperationError('validateFields', req, error);
  throw error;
}
```

**❌ INCORRECT Error Creation:**

```javascript
// DON'T DO THIS - Manual error creation without traceId
throw createStandardError(
  ERROR_TYPES.VALIDATION,
  'Required field is missing',
  { severity: ERROR_SEVERITY.MEDIUM }
); // ❌ No traceId context
```

### 3. Database Operations

**✅ CORRECT Database Logging:**

```javascript
// Log database operations for performance monitoring
try {
  logDatabaseStart('get_user_resources', req, { userId: user.id, filters });
  
  const resources = await prisma.resource.findMany({
    where: { userId: user.id, ...filters },
    include: { category: true },
  });
  
  logDatabaseSuccess('get_user_resources', req, { count: resources.length });
  return resources;
} catch (error) {
  logOperationError('getUserResources', req, error);
  throw handleDatabaseError(error, 'get_user_resources');
}
```

### 4. Validation Error Handling

**✅ CORRECT Validation Pattern:**

```javascript
let values;
try {
  values = await schema.validateAsync(body, {
    abortEarly: false,
    stripUnknown: true,
  });
} catch (error) {
  if (error.isJoi) {
    logOperationError('validateInput', req, error);
    throw handleValidationError(error, 'input_validation');
  }
  logOperationError('validateInput', req, error);
  throw error;
}
```

### 5. Custom Logging

**✅ CORRECT Custom Logging:**

```javascript
const { logWithTrace } = require('#utils/shared/traceUtils.js');

// For custom business logic logging
logWithTrace('Processing payment', req, { 
  amount: payment.amount, 
  method: payment.method 
});

// For external API calls
logWithTrace('Calling external service', req, { 
  service: 'payment-gateway', 
  endpoint: '/process' 
});
```

## Utility Functions Reference

### Core TraceId Utilities

| Function | Purpose | Usage |
|----------|---------|-------|
| `getTraceId(req)` | Extract traceId safely | `const traceId = getTraceId(req)` |
| `logWithTrace(message, req, data)` | Custom logging with traceId | `logWithTrace('Custom event', req, data)` |
| `createErrorWithTrace(type, message, req, options)` | Create errors with traceId | `createErrorWithTrace(ERROR_TYPES.VALIDATION, 'Error', req, options)` |

### Operation Logging

| Function | Purpose | When to Use |
|----------|---------|-------------|
| `logOperationStart(operation, req, data)` | Log operation beginning | Start of every controller function |
| `logOperationSuccess(operation, req, result)` | Log successful completion | Before sending response |
| `logOperationError(operation, req, error)` | Log operation failure | In catch blocks |

### Database Logging

| Function | Purpose | When to Use |
|----------|---------|-------------|
| `logDatabaseStart(operation, req, data)` | Log DB operation start | Before database calls |
| `logDatabaseSuccess(operation, req, result)` | Log DB operation success | After successful DB operations |

## Naming Conventions

### Operation Names
- Use camelCase: `createMicroservice`, `updateUser`, `deleteResource`
- Be descriptive: `getUserProjects` not `getProjects`
- Match controller function names when possible

### Database Operation Names
- Use snake_case: `create_microservice`, `update_user_profile`
- Include action: `create_`, `update_`, `delete_`, `get_`, `list_`
- Be specific: `get_user_active_sessions` not `get_sessions`

### Context Names
- Use snake_case: `user_validation`, `payment_processing`
- Include domain: `microservice_creation`, `user_authentication`

## TraceId Flow Architecture

```
HTTP Request
     ↓
[traceId Middleware] → Generate UUID, set req.traceId & X-Trace-ID header
     ↓
[Security Middleware] → Log [REQUEST_START] with traceId
     ↓
[Route Handler] → Use traceUtils for all logging
     ↓
[Controller] → logOperationStart → Database ops → logOperationSuccess
     ↓
[Error Handler] → Include traceId in error response
     ↓
[Security Middleware] → Log [REQUEST_END] with traceId
     ↓
HTTP Response (with X-Trace-ID header)
```

## Log Message Formats

### Standard Log Patterns
```
[TraceID: 123e4567-e89b-12d3-a456-426614174000] [OPERATION_START] createMicroservice | Data: {"user":"user123"}
[TraceID: 123e4567-e89b-12d3-a456-426614174000] [DB_START] create_microservice | Data: {"name":"test-service"}
[TraceID: 123e4567-e89b-12d3-a456-426614174000] [DB_SUCCESS] create_microservice | Result: {"id":"ms_123"}
[TraceID: 123e4567-e89b-12d3-a456-426614174000] [OPERATION_SUCCESS] createMicroservice | Result: {"id":"ms_123"}
```

### Error Log Patterns
```
[TraceID: 123e4567-e89b-12d3-a456-426614174000] [OPERATION_ERROR] createMicroservice failed: Validation error
[TraceID: 123e4567-e89b-12d3-a456-426614174000] [HIGH] VALIDATION: Input validation failed in microservice_creation
```

## Performance Considerations

### What to Log
- ✅ Operation start/success/failure
- ✅ Database operation start/success
- ✅ External API calls
- ✅ Critical business logic steps
- ✅ Authentication events
- ✅ Validation failures

### What NOT to Log
- ❌ Every line of code execution
- ❌ Sensitive data (passwords, tokens, PII)
- ❌ Large payloads in production
- ❌ Redundant information already captured

### Data Logging Guidelines
```javascript
// ✅ Good - Log relevant identifiers and counts
logDatabaseSuccess('get_user_orders', req, { 
  userId: user.id, 
  orderCount: orders.length,
  timeRange: filters.dateRange 
});

// ❌ Bad - Log sensitive or excessive data
logDatabaseSuccess('get_user_orders', req, orders); // Full data dump
logWithTrace('User login', req, { password: user.password }); // Sensitive data
```

## Testing TraceId Implementation

### Controller Tests
```javascript
describe('createResource', () => {
  it('should log operation lifecycle', async () => {
    const req = { traceId: 'test-trace-id', body: validData, user: testUser };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    
    await createResource(req, res);
    
    // Verify logging calls
    expect(logOperationStart).toHaveBeenCalledWith('createResource', req, expect.any(Object));
    expect(logOperationSuccess).toHaveBeenCalledWith('createResource', req, expect.any(Object));
  });
});
```

## Migration Guide

### For Existing Controllers
1. Add traceUtils imports
2. Replace manual `console.log` with `logOperationStart/Success/Error`
3. Replace manual traceId extraction with utility functions
4. Add database operation logging
5. Use `createErrorWithTrace` for error creation

### For New Development
1. Start every controller with `logOperationStart`
2. End every successful operation with `logOperationSuccess`
3. Log all database operations with `logDatabaseStart/Success`
4. Use `logOperationError` in all catch blocks
5. Never manually extract traceId - use utilities

## Common Anti-Patterns

### ❌ Manual TraceId Management
```javascript
// DON'T DO THIS
const traceId = req.traceId || 'unknown';
logEvent(`Creating resource`, traceId);
```

### ❌ Inconsistent Error Handling
```javascript
// DON'T DO THIS
catch (error) {
  console.error(error); // No traceId correlation
  throw error; // No enhancement
}
```

### ❌ Missing Operation Logging
```javascript
// DON'T DO THIS
const createResource = async (req, res) => {
  const resource = await prisma.resource.create(data);
  res.json(resource); // No operation tracking
};
```

### ❌ Logging Sensitive Data
```javascript
// DON'T DO THIS
logOperationStart('login', req, { 
  password: req.body.password // Sensitive data
});
```

## Troubleshooting

### Missing TraceId in Logs
- Ensure traceId middleware is applied early in middleware chain
- Check that utility functions are used instead of manual logging
- Verify request object is passed to all utility functions

### Performance Issues
- Reduce data logged in high-frequency operations
- Use appropriate log levels (don't log everything as high priority)
- Consider async logging for high-volume endpoints

### Error Correlation Issues
- Always use `createErrorWithTrace` for error creation
- Ensure `logOperationError` is called in all catch blocks
- Verify error handlers include traceId in response

## Best Practices Summary

1. **Always use utility functions** - Never manually extract traceId
2. **Log operation lifecycle** - Start, success, and errors
3. **Track database operations** - Critical for performance monitoring
4. **Enhance all errors** - Use `createErrorWithTrace`
5. **Be consistent** - Follow naming conventions
6. **Protect sensitive data** - Never log passwords, tokens, PII
7. **Test logging** - Verify traceId flows in tests
8. **Monitor performance** - Don't over-log high-frequency operations

This convention ensures consistent, traceable, and maintainable code across the entire application while providing comprehensive observability for debugging and monitoring.