// @gen:AUTO_GENERATED - This file is generated by compute-rapi
// apps/@gen{MICROSERVICE_SLUG}/src/config/entityRegistry.ts
import type { ComponentType } from 'react';
import type { ColumnConfig } from '@ps/shared-core/ui/DataTableV2/TableColumns';

// Import from the barrel file - this is OK because we only have 2 dynamic route pages importing it
import * as @gen{MICROSERVICE_NAME|Pascal} from '@ps/entity-core/@gen{MICROSERVICE_SLUG}';

export interface EntityConfig {
  // Display
  label: string;

  // Identifiers
  slug: string;
  pascalSingular: string;

  // API
  routeKey: string;
  importModel: string;

  // Components (lazy-loaded via property access)
  CreateForm: () => Promise<{ default: ComponentType<any> }>;
  DetailForm: () => Promise<{ default: ComponentType<any> }>;
  DetailCore: () => Promise<{ default: ComponentType<any> }>;
  columns: () => Promise<ColumnConfig[]>;
  dataMapper: () => Promise<(row: any) => any>;

  // Optional metadata
  helpfulHint?: string;
}

export type EntitySlug = keyof typeof entityRegistry;

// Entity entry - all naming variants pre-computed by generator
interface EntityEntry {
  slug: string;           // "asset-property-types"
  pascalSingular: string; // "AssetPropertyType"
  camelSingular: string;  // "assetPropertyType"
  label: string;          // "Asset Property Type"
  helpfulHint?: string;
}

// Pre-import all DetailCore components for dynamic access
// This is necessary because Next.js dynamic imports don't support template literals
// @gen:DETAIL_CORE_IMPORTS

// Map of slug to DetailCore component
const detailCoreMap: Record<string, ComponentType<any>> = {
  // @gen:DETAIL_CORE_MAP
};

/**
 * Generate entity config from pre-computed entry data
 */
function createEntityConfig(entry: EntityEntry): EntityConfig {
  const { slug, pascalSingular, camelSingular, label, helpfulHint } = entry;

  // Component names in the barrel file
  const createFormName = `${pascalSingular}Create`;
  const detailFormName = `${pascalSingular}Detail`;
  const columnsName = `${camelSingular}Columns`;
  const dataMapperName = `${camelSingular}DataMapper`;

  return {
    label,
    slug,
    pascalSingular,
    routeKey: `@gen{MICROSERVICE_SLUG}/get${pascalSingular}URL`,
    importModel: camelSingular,
    helpfulHint,

    // Access components from the barrel file using property access
    // This avoids webpack's template literal import issues
    CreateForm: async () => ({ default: (@gen{MICROSERVICE_NAME|Pascal} as any)[createFormName] }),
    DetailForm: async () => ({ default: (@gen{MICROSERVICE_NAME|Pascal} as any)[detailFormName] }),
    DetailCore: async () => ({ default: detailCoreMap[slug] }),
    columns: async () => (@gen{MICROSERVICE_NAME|Pascal} as any)[columnsName],
    dataMapper: async () => (@gen{MICROSERVICE_NAME|Pascal} as any)[dataMapperName],
  };
}

// All entity types for this microservice - generated from model definitions
// All naming variants are pre-computed by the generator from actual model data
const ENTITY_ENTRIES: EntityEntry[] = [
  // @gen:ENTITY_ENTRIES
];

// Build the registry from the entity entries
export const entityRegistry: Record<string, EntityConfig> = Object.fromEntries(
  ENTITY_ENTRIES.map(entry => [entry.slug, createEntityConfig(entry)])
);

/**
 * Get entity config by slug, throws if not found
 */
export function getEntityConfig(slug: string): EntityConfig {
  const config = entityRegistry[slug];
  if (!config) {
    throw new Error(`Unknown entity type: ${slug}`);
  }
  return config;
}

/**
 * Check if a slug is a valid entity type
 */
export function isValidEntitySlug(slug: string): slug is EntitySlug {
  return slug in entityRegistry;
}

/**
 * Get all entity slugs for static path generation
 */
export function getAllEntitySlugs(): string[] {
  return Object.keys(entityRegistry);
}
